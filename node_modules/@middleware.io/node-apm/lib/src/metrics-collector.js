"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const exporter_metrics_otlp_grpc_1 = require("@opentelemetry/exporter-metrics-otlp-grpc");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const resources_1 = require("@opentelemetry/resources");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
// @ts-ignore
const opentelemetry_node_metrics_1 = __importDefault(require("opentelemetry-node-metrics"));
const otlp_exporter_base_1 = require("@opentelemetry/otlp-exporter-base");
const perf_hooks_1 = require("perf_hooks");
const helper_1 = require("./helper");
const init = (config) => {
    let SERVICE_NAME = semantic_conventions_1.ATTR_SERVICE_NAME;
    const metricsExporter = getMetricExporter(config);
    const metricReader = new sdk_metrics_1.PeriodicExportingMetricReader({
        exporter: metricsExporter,
        exportIntervalMillis: 10000,
    });
    const serviceName = config.serviceName;
    const projectName = config.projectName;
    if (SERVICE_NAME === undefined) {
        SERVICE_NAME = "service.name";
    }
    let resourceAttributes = Object.assign({ [semantic_conventions_1.ATTR_SERVICE_NAME]: config.serviceName, ["mw_agent"]: true, ["project.name"]: config.projectName, ["mw.account_key"]: config.accessToken, ["mw_serverless"]: config.isServerless ? 1 : 0, ["mw.sdk.version"]: config.sdkVersion, ["runtime.metrics.nodejs"]: true, ["mw.app.lang"]: "nodejs" }, config.customResourceAttributes);
    (0, helper_1.addVCSMetadata)(resourceAttributes);
    const meterProvider = new sdk_metrics_1.MeterProvider({
        resource: new resources_1.Resource(resourceAttributes),
        readers: [metricReader],
    });
    config.meterProvider = meterProvider;
    const apmPauseMetrics = config.pauseMetrics || config.pauseMetrics === 1;
    if (!apmPauseMetrics) {
        (0, opentelemetry_node_metrics_1.default)(meterProvider);
        // Setup ELU monitoring if available
        setupEventLoopUtilizationMonitoring(meterProvider);
    }
};
exports.init = init;
function getMetricExporter(config) {
    if (config.consoleExporter) {
        return new sdk_metrics_1.ConsoleMetricExporter();
    }
    return new exporter_metrics_otlp_grpc_1.OTLPMetricExporter({
        url: config.target,
        compression: otlp_exporter_base_1.CompressionAlgorithm.GZIP,
    });
}
/**
 * Sets up monitoring for Event Loop Utilization when available.
 * This creates an observable gauge to track how busy the Node.js event loop is.
 *
 * @param meterProvider The OpenTelemetry meter provider
 */
function setupEventLoopUtilizationMonitoring(meterProvider) {
    if (!("eventLoopUtilization" in perf_hooks_1.performance)) {
        return;
    }
    let elu;
    const meter = meterProvider.getMeter("node-runtime-metrics");
    meter
        .createObservableGauge("runtime.node.event_loop.utilization", {
        description: "Node.js event loop utilization (0-1)",
    })
        .addCallback((observable) => {
        // If elu is undefined (first run), measurement is from start of process
        elu = perf_hooks_1.performance.eventLoopUtilization(elu);
        if (elu === null || elu === void 0 ? void 0 : elu.utilization) {
            observable.observe(elu.utilization);
        }
    });
}
