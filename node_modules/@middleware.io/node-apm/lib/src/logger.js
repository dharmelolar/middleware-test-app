"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = exports.loggerInitializer = void 0;
const api_logs_1 = require("@opentelemetry/api-logs");
const exporter_logs_otlp_grpc_1 = require("@opentelemetry/exporter-logs-otlp-grpc");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const resources_1 = require("@opentelemetry/resources");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const logform_1 = require("logform");
const { errors } = logform_1.format;
const errorsFormat = errors({ stack: true });
let transformError = errorsFormat.transform;
const otlp_exporter_base_1 = require("@opentelemetry/otlp-exporter-base");
const api_1 = __importDefault(require("@opentelemetry/api"));
const helper_1 = require("./helper");
const DEFAULT_LOG_KEYS = {
    traceId: "trace_id",
    spanId: "span_id",
    traceFlags: "trace_flags",
};
let logPackageName;
let logPackageVersion;
try {
    // Check for Package json in root project context
    const packageJsonPath = path_1.default.resolve(__dirname, "..", "..", "package.json");
    const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, "utf8"));
    logPackageName = packageJson.name;
    logPackageVersion = packageJson.version;
}
catch (e) {
    // Reverting to default values
    logPackageName = "unknown-package";
    logPackageVersion = "0.0.0";
}
/* Need this as maybe in client side ATTR_SERVICE_NAME results undefined due to version issues*/
let SERVICE_NAME = semantic_conventions_1.ATTR_SERVICE_NAME;
if (SERVICE_NAME === undefined) {
    SERVICE_NAME = "service.name";
}
const log = (level, message, attributes = {}) => {
    if (level === "ERROR") {
        // @ts-ignore
        let stack = transformError(message, { stack: true });
        // @ts-ignore
        message = typeof stack === "string" ? stack : stack.message;
        // @ts-ignore
        attributes["stack"] = stack && stack.stack ? stack.stack : "";
    }
    const logger = api_logs_1.logs.getLogger(logPackageName, logPackageVersion);
    let trace_id = null;
    let span_id = null;
    let trace_flags = null;
    let current_span = api_1.default.trace.getSpan(api_1.default.context.active());
    if (current_span) {
        trace_id = current_span.spanContext().traceId;
        span_id = current_span.spanContext().spanId;
        trace_flags = current_span.spanContext().traceFlags;
    }
    // @ts-ignore
    const severityNumber = api_logs_1.SeverityNumber[level];
    if (trace_id && span_id && trace_flags) {
        logger.emit({
            severityNumber,
            severityText: level,
            body: message,
            attributes: Object.assign({ "mw.app.lang": "nodejs", level: level.toLowerCase() }, (typeof attributes === "object" && Object.keys(attributes).length
                ? attributes
                : {})),
            [DEFAULT_LOG_KEYS.traceId]: trace_id,
            [DEFAULT_LOG_KEYS.spanId]: span_id,
            [DEFAULT_LOG_KEYS.traceFlags]: `0${trace_flags.toString(16)}`,
        });
    }
    else {
        logger.emit({
            severityNumber,
            severityText: level,
            body: message,
            attributes: Object.assign({ "mw.app.lang": "nodejs", level: level.toLowerCase() }, (typeof attributes === "object" && Object.keys(attributes).length
                ? attributes
                : {})),
        });
    }
};
exports.log = log;
const loggerInitializer = (config) => {
    let resourceAttributes = Object.assign({ [semantic_conventions_1.ATTR_SERVICE_NAME]: config.serviceName, ["mw_agent"]: true, ["project.name"]: config.projectName, ["mw.account_key"]: config.accessToken, ["mw_serverless"]: config.isServerless ? 1 : 0, ["mw.sdk.version"]: config.sdkVersion }, config.customResourceAttributes);
    (0, helper_1.addVCSMetadata)(resourceAttributes);
    const loggerProvider = new sdk_logs_1.LoggerProvider({
        resource: new resources_1.Resource(resourceAttributes),
    });
    loggerProvider.addLogRecordProcessor(new sdk_logs_1.BatchLogRecordProcessor(getLogsExporter(config)));
    api_logs_1.logs.setGlobalLoggerProvider(loggerProvider);
    /**
     * Bootstrap Logger Initialization
     * This section initializes the logger for the application's bootstrap process.
     * It creates a logger instance and emits the first log message indicating
     * that the logger has been successfully initialized.
     */
    const logger = loggerProvider.getLogger("init-logger");
    logger.emit({
        body: "Bootstrap: Logger initialized",
        attributes: {
            "mw.app.lang": "nodejs",
        },
    });
    if (config.consoleLog) {
        const originalConsoleLog = console.log;
        console.log = (...args) => {
            log("INFO", args.join(" "), {});
            originalConsoleLog(...args);
        };
    }
    if (config.consoleError) {
        const originalConsoleError = console.error;
        console.error = (...args) => {
            log("ERROR", args.join(" "), {});
            originalConsoleError(...args);
        };
    }
};
exports.loggerInitializer = loggerInitializer;
function getLogsExporter(config) {
    if (config.consoleExporter) {
        return new sdk_logs_1.ConsoleLogRecordExporter();
    }
    return new exporter_logs_otlp_grpc_1.OTLPLogExporter({
        url: config.target,
        compression: otlp_exporter_base_1.CompressionAlgorithm.GZIP,
    });
}
