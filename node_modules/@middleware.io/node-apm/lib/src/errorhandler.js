"use strict";
// errorHandler.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const api_1 = require("@opentelemetry/api");
// Extract function code from a stack trace file
function extractFunctionCode(filePath, lineNumber) {
    try {
        if (!fs_1.default.existsSync(filePath)) {
            return { functionCode: "Source file not found." };
        }
        const sourceLines = fs_1.default.readFileSync(filePath, "utf-8").split("\n");
        const totalLines = sourceLines.length;
        const startLine = Math.max(0, lineNumber - 10);
        const endLine = Math.min(totalLines, lineNumber + 10);
        const functionCode = sourceLines.slice(startLine, endLine).join("\n");
        return { functionCode, startLine, endLine };
    }
    catch (error) {
        return { functionCode: `Error extracting function code: ${error}` };
    }
}
// Custom function to record an exception
function customRecordException(span, error) {
    if (!span.isRecording())
        return;
    const stackTrace = error.stack ? error.stack.split("\n").slice(1) : [];
    const stackInfo = [];
    stackTrace.forEach((line) => {
        let match = line.match(/\s*at\s+(?:(.+?)\s+\()?(.*?):(\d+):(\d+)\)?/);
        if (match) {
            const [, functionName, filePath, lineNumber, columnNumber] = match;
            // Normalize filePath (resolve relative paths if necessary)
            const resolvedPath = filePath.startsWith("/") ? filePath : require.resolve(filePath);
            if (fs_1.default.existsSync(resolvedPath)) {
                const functionDetails = extractFunctionCode(resolvedPath, parseInt(lineNumber));
                stackInfo.push({
                    "exception.file": resolvedPath,
                    "exception.line": parseInt(lineNumber),
                    "exception.column_number": parseInt(columnNumber),
                    "exception.function_name": functionName || "anonymous",
                    "exception.function_body": functionDetails.functionCode,
                    "exception.start_line": functionDetails.startLine,
                    "exception.end_line": functionDetails.endLine,
                    "exception.is_file_external": resolvedPath.includes("node_modules")
                });
            }
        }
    });
    const mwVCSCommitSha = process.env.MW_VCS_COMMIT_SHA || "";
    const mwVCSRepositoryUrl = process.env.MW_VCS_REPOSITORY_URL || "";
    // Add exception event to the span
    span.addEvent("exception", {
        "exception.type": error.name,
        "exception.message": error.message,
        "exception.stacktrace": error.stack || "",
        "exception.language": "nodejs",
        "exception.stack_details": JSON.stringify(stackInfo, null, 2),
    });
    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error.message });
}
const errorHandler = (err, req, res, next) => {
    const tracer = api_1.trace.getTracer("mw-tracer");
    const span = api_1.trace.getSpan(api_1.context.active());
    if (span) {
        customRecordException(span, err);
    }
    else {
        // If no active span, create a new one
        tracer.startActiveSpan(err.name, (span) => {
            customRecordException(span, err);
            span.end();
        });
    }
    // Determine status code
    const statusCode = err.statusCode ||
        (err.name === "ValidationError" ? 400 :
            err.name === "UnauthorizedError" ? 401 :
                err.name === "ForbiddenError" ? 403 :
                    err.name === "NotFoundError" ? 404 :
                        err.name === "ConflictError" ? 409 :
                            err.name === "ServiceUnavailable" ? 503 : 500);
    res.status(statusCode).json({
        message: err.message || "An unexpected error occurred",
        status: statusCode,
    });
};
exports.default = errorHandler;
