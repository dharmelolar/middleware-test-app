"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shutdown = exports.init = void 0;
const sdk_node_1 = require("@opentelemetry/sdk-node");
const auto_instrumentations_node_1 = require("@opentelemetry/auto-instrumentations-node");
const exporter_trace_otlp_grpc_1 = require("@opentelemetry/exporter-trace-otlp-grpc");
const otlp_exporter_base_1 = require("@opentelemetry/otlp-exporter-base");
// import { GrpcInstrumentation } from "@opentelemetry/instrumentation-grpc";
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const core_1 = require("@opentelemetry/core");
const propagator_b3_1 = require("@opentelemetry/propagator-b3");
const resources_1 = require("@opentelemetry/resources");
const mwresourceDetector_1 = require("./mwresourceDetector");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const helper_1 = require("./helper");
let sdk = null;
// Debug logging wrapper function
const debugLog = (config, message) => {
    if (config.DEBUG) {
        console.log(message);
    }
};
const init = (config) => {
    const apm_pause_traces = config.pauseTraces === true;
    let resourceAttributes = Object.assign({ [semantic_conventions_1.ATTR_SERVICE_NAME]: config.serviceName, ["mw_agent"]: true, ["project.name"]: config.projectName, ["mw.account_key"]: config.accessToken, ["mw_serverless"]: config.isServerless ? 1 : 0, ["mw.sdk.version"]: config.sdkVersion }, config.customResourceAttributes);
    (0, helper_1.addVCSMetadata)(resourceAttributes);
    if (!apm_pause_traces) {
        sdk = new sdk_node_1.NodeSDK({
            textMapPropagator: new core_1.CompositePropagator({
                propagators: [
                    new propagator_b3_1.B3Propagator(),
                    new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER }),
                ],
            }),
            resourceDetectors: (0, mwresourceDetector_1.resourceDetectors)(),
            resource: new resources_1.Resource(resourceAttributes),
            traceExporter: getTraceExporter(config),
            instrumentations: [
                (0, auto_instrumentations_node_1.getNodeAutoInstrumentations)(createInstrumentationConfig(config)),
                // new GrpcInstrumentation({
                //   ignoreGrpcMethods: ["Export"],
                // }),
            ],
        });
        sdk.start();
    }
};
exports.init = init;
function createInstrumentationConfig(config) {
    const instrumentationConfig = {};
    // DISABLING IT AS IT HAS SEVERE IMPACT ON PERFORMANCE
    instrumentationConfig["@opentelemetry/instrumentation-fs"] = {
        enabled: false,
    };
    instrumentationConfig["@opentelemetry/instrumentation-graphql"] = {
        mergeItems: true,
    };
    const instrumentations = {
        dns: "@opentelemetry/instrumentation-dns",
        net: "@opentelemetry/instrumentation-net",
        socket: "@opentelemetry/instrumentation-socket.io",
        ioredis: "@opentelemetry/instrumentation-ioredis",
        pg: "@opentelemetry/instrumentation-pg",
        express: "@opentelemetry/instrumentation-express",
        fastify: "@opentelemetry/instrumentation-fastify",
        pino: "@opentelemetry/instrumentation-pino",
        mongodb: "@opentelemetry/instrumentation-mongodb",
        mongoose: "@opentelemetry/instrumentation-mongoose",
        grpc: "@opentelemetry/instrumentation-grpc",
        redis: "@opentelemetry/instrumentation-redis",
        "redis-client": "@opentelemetry/instrumentation-redis-4",
        knex: "@opentelemetry/instrumentation-knex",
        "generic-pool": "@opentelemetry/instrumentation-generic-pool",
        "aws-sdk": "@opentelemetry/instrumentation-aws-sdk",
    };
    config.disabledInstrumentations.split(",").forEach((item) => {
        const name = item.trim();
        if (name !== "" && name in instrumentations) {
            instrumentationConfig[instrumentations[name]] = { enabled: false };
        }
    });
    if (!config.disabledInstrumentations.includes("grpc")) {
        instrumentationConfig["@opentelemetry/instrumentation-grpc"] = {
            ignoreGrpcMethods: ["Export"],
        };
    }
    // By Default Ignoring Pyroscope Instrumented spans
    let pyroscopeIgnoreHook;
    if (!config.enableSelfInstrumentation) {
        debugLog(config, "[node-apm] Pyroscope self-instrumentation is disabled");
        pyroscopeIgnoreHook = (request) => {
            if ((request === null || request === void 0 ? void 0 : request.path) && request.path.includes("/profiling/ingest"))
                return true;
            return false;
        };
    }
    // Get configuration for incoming and outgoing request exclusions
    const excludeConfig = config.excludeHttpTraces;
    const incomingConfig = (excludeConfig === null || excludeConfig === void 0 ? void 0 : excludeConfig.incoming) || {};
    const outgoingConfig = (excludeConfig === null || excludeConfig === void 0 ? void 0 : excludeConfig.outgoing) || {};
    const incomingExcludedMethods = incomingConfig.methods || [];
    const incomingExcludedUrls = incomingConfig.urls || [];
    const outgoingExcludedMethods = outgoingConfig.methods || [];
    const outgoingExcludedUrls = outgoingConfig.urls || [];
    debugLog(config, `[node-apm] Incoming excluded HTTP methods: ${incomingExcludedMethods}`);
    debugLog(config, `[node-apm] Incoming excluded HTTP URLs: ${incomingExcludedUrls}`);
    debugLog(config, `[node-apm] Outgoing excluded HTTP methods: ${outgoingExcludedMethods}`);
    debugLog(config, `[node-apm] Outgoing excluded HTTP URLs: ${outgoingExcludedUrls}`);
    // Apply exclusion rules if any are configured
    const hasExclusions = incomingExcludedMethods.length > 0 ||
        incomingExcludedUrls.length > 0 ||
        outgoingExcludedMethods.length > 0 ||
        outgoingExcludedUrls.length > 0;
    // Set up HTTP instrumentation if we have exclusions OR need to apply pyroscope hook
    if (hasExclusions || pyroscopeIgnoreHook) {
        instrumentationConfig["@opentelemetry/instrumentation-http"] = {
            ignoreOutgoingRequestHook: (request) => {
                // Exclude by URL
                debugLog(config, `[node-apm] Checking outgoing request: ${request === null || request === void 0 ? void 0 : request.path}`);
                if ((request === null || request === void 0 ? void 0 : request.path) &&
                    outgoingExcludedUrls.length > 0 &&
                    outgoingExcludedUrls.some((url) => request.path && request.path.includes(url))) {
                    debugLog(config, `[node-apm] Dropping span for excluded outgoing URL: ${request.path}`);
                    return true;
                }
                // Exclude by method
                if ((request === null || request === void 0 ? void 0 : request.method) && outgoingExcludedMethods.length > 0) {
                    if (outgoingExcludedMethods.includes(request.method.toUpperCase())) {
                        debugLog(config, `[node-apm] Dropping span for excluded outgoing HTTP method: ${request.method} ${request.path || ""}`);
                        return true;
                    }
                }
                // Calling pyroscope   ignore hook
                if (typeof pyroscopeIgnoreHook === "function") {
                    return pyroscopeIgnoreHook(request);
                }
                return false;
            },
            ignoreIncomingRequestHook: (request) => {
                // Exclude by URL
                debugLog(config, `[node-apm] Checking incoming request: ${request === null || request === void 0 ? void 0 : request.url}`);
                if ((request === null || request === void 0 ? void 0 : request.url) &&
                    incomingExcludedUrls.length > 0 &&
                    incomingExcludedUrls.some((url) => request.url && request.url.includes(url))) {
                    debugLog(config, `[node-apm] Dropping span for excluded incoming URL: ${request.url}`);
                    return true;
                }
                // Exclude by method
                if ((request === null || request === void 0 ? void 0 : request.method) && incomingExcludedMethods.length > 0) {
                    if (incomingExcludedMethods.includes(request.method.toUpperCase())) {
                        debugLog(config, `[node-apm] Dropping span for excluded incoming HTTP method: ${request.method} ${request.url || ""}`);
                        return true;
                    }
                }
                return false;
            },
        };
    }
    return instrumentationConfig;
}
const shutdown = () => __awaiter(void 0, void 0, void 0, function* () {
    if (sdk) {
        try {
            yield sdk.shutdown();
            console.log("OpenTelemetry SDK shut down successfully");
        }
        catch (err) {
            console.log("OpenTelemetry SDK shut down failed");
        }
    }
    else {
        console.log("OpenTelemetry SDK was not initialized, nothing to shut down");
    }
});
exports.shutdown = shutdown;
function getTraceExporter(config) {
    if (config.consoleExporter) {
        return new sdk_trace_node_1.ConsoleSpanExporter();
    }
    return new exporter_trace_otlp_grpc_1.OTLPTraceExporter({
        url: config.target,
        compression: otlp_exporter_base_1.CompressionAlgorithm.GZIP,
    });
}
